#▄────────────────────────────────────────────▄1.0.2
#█                                            █
#█  ModelView: Runner                         █
#█  • Запуск команд (управление интерфейсом)  █
#█                                            █
#▀────────────────────────────────────────────▀
modelView:Runner() { case "$1" in
#┌─────────────────────────┐
#│ Выполняет список команд │
#└─────────────────────────┘
    'run_list')
    # Сохраняем имя функции родителя
        RUNNER_CLASS="${FUNCNAME[2]#*:}"
        
    # Очищаем экран
        reset
        
    # Обновляем заголовок
        "view:$RUNNER_CLASS" 'header'
        
    # Переносим строку
        printf '\n'
        
    # Сохраняем позицию курсора
        printf '\e[s'
            
    # Сохраняем общее количество шагов
        let RUNNER_FULL=$#-1
        
    # Локальные переменные
        local i
        
    # Проходим по списку команд
        for ((i = 2; i <= $#; i++)); do
        # Сохраняем текущую команду
            RUNNER_COMMAND="${!i}"
            
        # Сохраняем текущий шаг
            let RUNNER_NOW=$i-1
            
        # Выполняем команду
            if modelView:Runner 'run'; then
            # Команда не была выполнена
                return 1
            fi
        done
        
    # Выводим сообщение об успешном завершении
        "view:$RUNNER_CLASS" 'success'
        
    # Все команды успешно выполнены
        return 0
    ;;
    
#┌───────────────────┐
#│ Выполняет команду │
#└───────────────────┘
    'run')
    # Создаем потоковый стрим
        local stream='stream'
        
    # Если в имени команды присутствует "void:command_name"
    # Это говорит о том, что в данной ситуации потоковый стрим не нужен
    # Так же это говорит о том, что в команде будут переопределены глобальные переменные
        if [[ "${RUNNER_COMMAND/:*}" == 'void' && "${RUNNER_COMMAND/:*}" != "$RUNNER_COMMAND" ]]; then
            stream='stream:Void'
        fi
        
    # Обновляем текущее состояние команды
        modelView:Runner 'state'
        
    # Выполняем команду
        if "$stream" "runner:$RUNNER_CLASS" "$RUNNER_COMMAND"; then
        # Выводим сообщение об ошибке
            "view:$RUNNER_CLASS" 'error' "$RUNNER_COMMAND"
            
        # Команда не была выполнена
            return 0
        fi
        
    # Команда успешно выполнена
        return 1
    ;;
    
#┌─────────────────────────────────────┐
#│ Обновляет текущее состояние команды │
#└─────────────────────────────────────┘
    'state')
    # Сохраняем состояние команды
        RUNNER_VIEW="$1";
        
    # Перемещаем курсор на следующую строку
        printf '\e[E'
        
    # Обновляем текущее состояние команды
        "view:$RUNNER_CLASS" "$RUNNER_VIEW" "$RUNNER_COMMAND"
        
    # Режим разаработки
        if [[ "$DEV_MODE" == 1 ]]; then
            read
        fi
    ;;
    
#┌────────────────────────────┐
#│ Обновляет текущий прогресс │
#└────────────────────────────┘
    'progress')
    # Сохраняем состояние команды
        RUNNER_VIEW="$1";
        
    # Обновляем текущий прогресс
        local message="$("view:$RUNNER_CLASS" "$RUNNER_VIEW" "$RUNNER_COMMAND")"
        
    # Выводим сообщение в лог
        printf "$message" "${@:2}"
    ;;
    
#┌─────────────────────────────────────┐
#│ Обновляет текущее состояние команды │
#└─────────────────────────────────────┘
    'message')
    # Локальные переменные
        local message # Сообщение
        
    # Проходим по списку сообщений
        for message in "${@:2}"; do
        # Обновляем шаг
            printf '[%d/%d] ' "$RUNNER_NOW" "$RUNNER_FULL"
            
        # Обновляем текущее состояние команды
            printf '%s' "$message"
            
        # Удаляем все символы до конца строки
            printf '\e[K'
            
        # Переносим строку
            printf '\n'
        done
    ;;
    
#┌───────────────────────────┐
#│ Сохраняет сообщения в лог │
#└───────────────────────────┘
    'log')
    # Список состояний команды
        case "$RUNNER_VIEW" in
        # Состояние команды
            'state')
            # Восстанавливаем позицию курсора
                printf '\e[u'
                
            # Обновляем текущее состояние команды
                modelView:Runner 'message' "${@:2}"
                
            # Удаляем все после текущей позиции
                printf '\e[J'
            ;;
            
        # Прогресс
            'progress')
            # Перемещаем курсор на следующую строку
                printf '\e[E'
                
            # Перемещаем курсор на предыдущую строку (два раза)
                printf '\e[F\e[F'
                
            # Обновляем текущее состояние команды
                modelView:Runner 'message' "${@:2}"
            ;;
        esac
    ;;
esac
}

#▄──────────────▄
#█              █
#█  Namespaces  █
#█              █
#▀──────────────▀
runner()   { modelView:Runner 'run_list' "$@"; } # Выполняет список команд
progress() { modelView:Runner 'progress' "$@"; } # Обновляет текущий прогресс
log()      { modelView:Runner 'log'      "$@"; } # Сохраняет сообщение в лог
