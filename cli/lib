#▄──────────────────────────────────────────▄1.0.33
#█                                          █
#█  Путь к каталогу где расположен скрипт,  █
#█  который загрузил эту библиотеку         █
#█                                          █
#▀──────────────────────────────────────────▀
C9_PATH=$(dirname $0)

#▄──────────────────────────────────────────▄
#█                                          █
#█  Переопределяем сочетание клавиш Ctrl+C  █
#█                                          █
#▀──────────────────────────────────────────▀
ctrl_c() {
    reset # Очистка экрана
    exit # Завершение процесса
}
trap ctrl_c 2

#┌───────────────────┐
#│ Список переменных │
#└───────────────────┘
typeset -a menuItems # Список пунктов меню
typeset -A menuState # Список сохраненных состояний пунктов меню

#▄────────▄
#█        █
#█  Меню  █
#█        █
#▀────────▀
#┌───────────────────────┐
#│ Выводит меню на экран │
#└───────────────────────┘
menu() {
# Очищаем экран
    reset
    
# Выводим заголовок
    printf '%b ' "$1"
    
# Сохраняем позицию курсора
    printf '\e[s'
    
# Переносим строку два раза
    printf '\n\n'
    
# Добавляем выбранный пункт
    menuItems=("$2")
}

#┌─────────────────────────────────────────────┐
#│ Добавляет новый пункт в список пунктов меню │
#└─────────────────────────────────────────────┘
menuAddItem() {
    menuItems+=("$1" "$2")
}

#┌────────────────────────────────┐
#│ Добавляет пункты разных цветов │
#└────────────────────────────────┘
Yellow() { menuAddItem 'Yellow' "$1"; }
Green() { menuAddItem 'Green' "$1"; }
Red() { menuAddItem 'Red' "$1"; }

#┌───────────────────────────────────────────────────┐
#│ Добавляет последний пункт и выводит меню на экран │
#└───────────────────────────────────────────────────┘
Exit() {
# Добавляем последний пункт
    menuAddItem "$2" "$1"
    
# Локальные переменные
    local selection="${menuItems[0]}" # Выбранный пункт
    local menuID="${menuItems[*]:1}"  # ID-меню
    local i
    
# Удаляем первый элемент массива
    menuItems=("${menuItems[@]:1}")
    
# Проходим по пунктам меню
    for ((i = 0; i < ${#menuItems[*]} / 2; i++)); do
        printf '\n'
    done
    
# Проверяем есть-ли сохраненное состояние пунктов меню
    if [[ "${menuState[$menuID]}" != '' ]]; then
        selection="${menuState[$menuID]}"
    fi
    
# Выводим подсказку
    printf '\n' # Перенос строки
    printf '\e[44m' # Синий фон
    printf '\e[K' # Удаление всех символов до конца строки
    printf ' Выбор: [ENTER], Навигация: [Page Up] / [Page Down] '
    printf '\e[0m' # Сброс цвета
    printf '\n'
    
# Обновляем пункты меню
    menuUpdate "$selection"
    
# Сохраняем новое состояние выбранного пункта меню
    [[ "$menuID" != '' ]] && menuState[$menuID]=$REPLY
    
# Выбран не последний пункт
    (( $REPLY < ${#menuItems[*]} / 2 )) && return $REPLY
    
# Выбран последний пункт
    return 0
}

#┌───────────────────────┐
#│ Обновляет пункты меню │
#└───────────────────────┘
menuUpdate() {
# Локальные переменные
    local count=$(( ${#menuItems[*]} / 2 )) # Количество пунктов
    local color          # Цвет фона
    local color0='\e[0m' # Сброс цвета
    local length=0       # Длина самого длинного пункта
    local selection      # Выбранный пункт
    local i
    
# Переводим строку в число
    selection=$(number "$1")
    
# Выбран пункт: "Exit"
    if (( $selection <= 0 || $selection > $count )); then
        selection=$count
    fi
    
# Вычисляем длину
    for ((i = 0; i < ${#menuItems[*]}; i += 2)); do
        if (( $length < ${#menuItems[$i+1]})); then
            length=${#menuItems[$i+1]}
        fi
    done
    
# Восстанавливаем позицию курсора
    printf '\e[u'
    
# Удаляем все символы до конца строки
    printf '\e[K'
    
# Переносим строку два раза
    printf '\n\n'
    
# Проходим по пунктам меню
    for ((i = 0; i < ${#menuItems[*]}; i += 2)); do
    # Преобразуем цвет фона в эскейп последовательность
        case "${menuItems[$i]}" in
            'Yellow') color='\e[43m' ;;  # Желтый фон
            'Green')  color='\e[42m' ;;  # Зеленый фон
            'Red')    color='\e[41m' ;;  # Красный фон
            *)        color='\e[100m' ;; # Серый фон
        esac
        
    # Отступ слева
        printf ' '
        
    # Удаляем все символы до конца строки
        printf '\e[K'
        
    # Пункт меню выбран
        if (( $i / 2 == $selection - 1 )); then
        # Цвет фона
            printf '%b' "$color"
            
        # Текст
            printf ' %b ' "${menuItems[$i+1]}"
            
        # Ширина фона
            printf '%b' "$(char $(( $length - ${#menuItems[$i+1]} )) ' ')"
            
        # Сброс цвета
            printf '%b' "$color0"
            
    # Пункт меню НЕ выбран
        else
        # Текст
            printf ' %b ' "${menuItems[$i+1]}"
        fi
        
    # Переносим строку
        printf '\n'
    done
    
# Удаляем все символы до конца строки
    printf '\e[K'
    
# Восстанавливаем позицию курсора
    printf '\e[u'
    
# Локальные переменные
    local keyPageDown=`printf '\e[B'`
    local keyPageUp=`printf '\e[A'`
    local keyEnter=`printf '\n'`
    local keyESC=`printf '\e'`
    local extra=''
    local key=''
    
# Ожидаем пока пользователь передаст команду с клавиатуры
    read -s -r -n1 key &> '/dev/null'
    while read -s -n1 -t .05 extra &> '/dev/null' ; do
        key="$key$extra"
    done
    
# Обрабатываем переданную команду с клавиатуры
    case "$key" in
    # Exit
        "$keyESC" | '`' | 'q' | 0)
        # Эмуляция двойного нажатия
            if [[ $selection == $count ]]; then
                REPLY=$count
                return
            fi
            selection=$count
        ;;
        
    # Up
        "$keyPageUp")
            if (( $selection > 1 )); then
                let 'selection--'
            else
                selection=$count
            fi
        ;;
        
    # Down
        "$keyPageDown")
            if (( $selection < $count )); then
                let 'selection++'
            else
                selection=1
            fi
        ;;
        
    # Цифры от 1 до 9
        [1-9])
            if (( $count > $key )); then
            # Эмуляция двойного нажатия
                if [[ $selection == $key ]]; then
                    REPLY=$key
                    return
                fi
                selection=$key
            fi
        ;;
        
    # Enter
        "$keyEnter")
            REPLY=$selection
            return
        ;;
    esac
    
# Обновляем пункты меню
    menuUpdate "$selection"
}

#┌─────────────────────────────────────────────┐
#│ Обнуляет сохраненные состояния пунктов меню │
#└─────────────────────────────────────────────┘
menuRestart() {
    menuState=()
}

#▄─────────▄
#█         █
#█  Input  █
#█         █
#▀─────────▀
#┌─────────────────────────────────────────┐
#│ Проверяет верно-ли указан порт          │
#│ • Диапазон от 1 до 65536 (включительно) │
#└─────────────────────────────────────────┘
isValidPort() {
    [[ ! "$1" =~ ^[0-9]*[0-9]$ ]] && return 1
    (( "$1" > 0 && "$1" < 65537 ))
}

#┌────────────────────────────────────────────┐
#│ Проверяет верно-ли указано имя юзера       │
#│ • Длина от 2 до 39 символов (включительно) │
#│ • Символы [a-zA-Z0-9], и тире "-"          │
#│ • Тире не допускается в начале и в конце   │
#└────────────────────────────────────────────┘
isValidUsername() {
    (( ${#1} > 39 )) && return 1
    [[ "$1" =~ ^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]+$ ]]
}

#┌────────────────────────────────────────────────────────────────────────┐
#│ Просит пользователя ввести данные вручную                              │
#├────────────────────────────────────────────────────────────────────────┤
#│ Пример вызова:                                                         │
#│ input <значение по умолчанию> <функция проверки> <сообщение об ошибке> │
#│ input 'build' 'isValidCommand' "Команда '%s' не найдена!"              │
#└────────────────────────────────────────────────────────────────────────┘
input() {
# Выделяем строку ввода
    printf '\e[44m' # Синий фон
    printf '\e[K' # Удаление всех символов до конца строки
    
# Просим пользователя ввести данные вручную
    read -e -r -p '$ ' -i "$1"
    
# Если данные введены не верно
    if ! $("$2" "$REPLY"); then
        printf '\e[0m' # Сброс цвета
        printf '\r' # Возврат в начало строки
        printf '\e[A' # Переход на одну строку вверх
        printf '\e[K' # Удаление всех символов до конца строки
        
    # Выводим сообщение об ошибке
        printf "Ошибка! $3\n" "$REPLY"
        
    # Просим пользователя ввести данные еще раз
        input "$REPLY" "$2" "$3"
    fi
}

#▄───────────────▄
#█               █
#█  Уведомление  █
#█               █
#▀───────────────▀
#┌──────────────────────┐
#│ Выводит символ N раз │
#│ Пример: char 3 'abс' │
#│ Результат: abсabсabс │
#└──────────────────────┘
char() {
    local i
    for ((i = 0; i < "$1"; i++)); do printf "$2"; done
}

#┌──────────────────────────────┐
#│ Выводит уведомление на экран │
#└──────────────────────────────┘
notice() {
# Локальные переменные
    local length=0
    local msg
    local i
    
# Вычисляем длину
    for ((i = 2; i <= $#; i++)); do
        msg=$(printf '%b' "${!i}")
        if (( $length < ${#msg})); then
            length=${#msg}
        fi
    done
    
# Преобразуем цвет в эскейп последовательность
    case "$1" in
        'Yellow') printf '\e[33m' ;; # Желтый текст
        'Green')  printf '\e[32m' ;; # Зеленый текст
        'Red')    printf '\e[31m' ;; # Красный текст
    esac
    
# Верхняя часть
    printf '▄──%s──▄\n' "$(char $length '─')"
    printf '█  %s  █\n' "$(char $length ' ')"
    
# Сообщение
    for ((i = 2; i <= $#; i++)); do
        msg="${!i}"
        printf '█  %s%s  █\n' "$msg" "$(char $(($length - ${#msg})) ' ')"
    done
    
# Нижняя часть
    printf '█  %s  █\n' "$(char $length ' ')"
    printf '▀──%s──▀\n' "$(char $length '─')"
    
# Сбрасываем цвет
    printf '\e[0m'
}

#┌─────────────────────────────┐
#│ Выводит сообщение об ошибке │
#└─────────────────────────────┘
notice_error() {
# Добавляем красный цвет
    local error_msg='\e[31m'
    
# Проходим по списку ошибок
    for ((i = 1; i < $#; i++)); do
        error_msg="${error_msg}${!i}\n"
    done
    
# Сбрасываем цвет
    error_msg="${error_msg}\e[0m"
    
# Заголовок
    echo "${error_msg}$(notice 'Red' "Ошибка! ${!i}")"
}

#▄──────▄
#█      █
#█  Is  █
#█      █
#▀──────▀
#┌───────────────────────────────────────────────┐
#│ Проверяет существуют-ли образы, далее         │
#│ присваивает найденые ID переменной $GLOBAL_ID │
#│ is_image "$IMAGE_NAME"                        │
#└───────────────────────────────────────────────┘
is_image() {
# Локальные переменные
    local ids
    local i
    
# Получаем ID образов
    GLOBAL_ID=$(docker images -aq "$1" 2>&1)
    
# Переводим в массив
    ids=($GLOBAL_ID)
    
# Массив пуст
    if [[ ${#ids[*]} == 0 ]]; then
        return 1
    fi
    
# Проходим по списку ID-образов
    for ((i = 0; i < ${#ids[*]}; i++)); do
    # Проверяем длину ID
        if [[ ${#ids[$i]} != '12' ]]; then
            return 1
        fi
    done
    
# Образы существуют
    return 0
}

#┌───────────────────────────────────────────────┐
#│ Проверяет существуют-ли контейнеры, далее     │
#│ присваивает найденые ID переменной $GLOBAL_ID │
#│ is_container "ancestor=$IMAGE_NAME"           │
#│ is_container "name=$IMAGE_NAME"               │
#└───────────────────────────────────────────────┘
is_container() {
# Локальные переменные
    local ids
    local i
    
# Получаем ID контейнеров
    GLOBAL_ID=$(docker ps -aq --filter "$1" 2>&1)
    
# Переводим в массив
    ids=($GLOBAL_ID)
    
# Массив пуст
    if [[ ${#ids[*]} == 0 ]]; then
        return 1
    fi
    
# Проходим по списку ID-контейнеров
    for ((i = 0; i < ${#ids[*]}; i++)); do
    # Проверяем длину ID
        if [[ ${#ids[$i]} != '12' ]]; then
            return 1
        fi
    done
    
# Контейнеры существуют
    return 0
}

#▄────────▄
#█        █
#█  Base  █
#█        █
#▀────────▀
#┌──────────────────────────┐
#│ Переводит строку в число │
#└──────────────────────────┘
number() {
    printf '%d' "$1" 2> '/dev/null'
}

#┌───────────────────────────────────────┐
#│ Экранирует все спец. символы в строке │
#└───────────────────────────────────────┘
escape() {
    printf '%q' "$1" 2> '/dev/null'
}
